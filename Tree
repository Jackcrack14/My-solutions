# Tree Traversal(Inorder,Preorder,Postorder) 
# Using Recursion

class Node() :
    def __init__ (self,data) :
        self.data = data
        self.left = None
        self.right = None
        
def Inorder(root) :   # Inorder Traversal
    if root :
        Inorder(root.left)
        print(root.data)
        Inorder(root.right)
                    
def Preorder(root):   # Preorder Traversal
    if root :
        print(root.data)
        Inorder(root.left)
        Inorder(root.right)

def Postorder(root) :  # Postorder Traversal
    if root :
        Inorder(root.left)
        Inorder(root.right)
        print(root.data)
        
# Morris Traversal(Inorder,Preorder)
# It uses concept of Threaded binary Tree
                
def Morris_Inorder(root) :
class Node() :
    def __init__(self,val) :
        self.val = val
        self.right = None
        self.left = None

def Morris_in(root) :
    current = root
    while current is not None :
        if current.left is None :
            yield current.val
            current = current.right
        else :
            pre = current.left
            while pre.right is not None and pre.right != current :
                pre = pre.right
            if pre.right is None :
                pre.right = current # Threading Step                
                current = current.left
            else :
                pre.right = None
                yield current.val
                current = current.right

def Morris_Preorder(root) :
    current = root
    while current is not None :
        if current.left is None :
            yield current.val
            current = current.right
        else :
            pre = current.left
            while pre.right is not None and pre.right != current :
                pre = pre.right
            if pre.right is None :
                pre.right = current # Threading Step
                 yield current.val
                current = current.left
            else :
                pre.right = None             
                current = current.right

# Constructing Binary Tree from Parent  Array 


from collections import defaultdict
parent = [-1,0,0,1,1,3,5]
child = [idx for idx in range(7)] 
graph = defaultdict(list)
for i in range(7) :
    if parent[i] == -1 :
        continue
    else :
        graph[parent[i]].append(child[i])
print(graph)
def bfs(full_list,graph,node) :
    path =[]
    path.append(node)
    while path :
        cur = path.pop(0)
        print(cur)
        for neighbour in graph[cur] :
            if neighbour not in full_list :
                full_list.append(neighbour)
                path.append(neighbour)
    
print(bfs([],graph,0))
# Diameter of a Tree

class node :
    def __init__(self,data) :
        self.data = data
        self.left = None
        self.right = None
class Height :
    def __init__(self) :
        self.h = 0
def postorder(root,height) :
    lh = Height()
    rh = Height()
    if root is None :
        height.h = 0
        return 0
    l_diameter = postorder(root.left,lh)
    r_diameter = postorder(root.right,rh)

    height.h = max(lh.h, rh.h) + 1

    return max(lh.h+rh.h+1,max(l_diameter,r_diameter))

def util_postorder(self) :
    h = Height()
    return postorder(root,h)


root = node(4)
root.left = node(7)
root.right = node(8)
root.right.left = node(1)
root.right.right = node(3)
root.right.left.left = node(0)

print(util_postorder(root))
